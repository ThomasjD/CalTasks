{"ast":null,"code":"import { DropTarget } from 'react-dnd';\nimport { getPos } from './Util';\nimport { DnDTypes } from './DnDTypes';\nimport { CellUnits, DATETIME_FORMAT } from './index';\nimport { ViewTypes } from './ViewTypes';\nexport default class DnDContext {\n  constructor(sources, DecoratedComponent) {\n    this.getDropSpec = () => {\n      return {\n        drop: (props, monitor, component) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents;\n          const cellUnit = schedulerData.cellUnit,\n                localeMoment = schedulerData.localeMoment;\n          const type = monitor.getItemType();\n          const pos = getPos(component.eventContainer);\n          let cellWidth = schedulerData.getContentCellWidth();\n          let initialStartTime = null,\n              initialEndTime = null;\n\n          if (type === DnDTypes.EVENT) {\n            const initialPoint = monitor.getInitialClientOffset();\n            let initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n            initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n            initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n            if (cellUnit !== CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          }\n\n          const point = monitor.getClientOffset();\n          let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n          let startTime = resourceEvents.headerItems[leftIndex].start;\n          let endTime = resourceEvents.headerItems[leftIndex].end;\n          if (cellUnit !== CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          return {\n            slotId: resourceEvents.slotId,\n            slotName: resourceEvents.slotName,\n            start: startTime,\n            end: endTime,\n            initialStart: initialStartTime,\n            initialEnd: initialEndTime\n          };\n        },\n        hover: (props, monitor, component) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents,\n                movingEvent = props.movingEvent;\n          const cellUnit = schedulerData.cellUnit,\n                config = schedulerData.config,\n                viewType = schedulerData.viewType,\n                localeMoment = schedulerData.localeMoment;\n          const item = monitor.getItem();\n          const type = monitor.getItemType();\n          const pos = getPos(component.eventContainer);\n          let cellWidth = schedulerData.getContentCellWidth();\n          let initialStart = null,\n              initialEnd = null;\n\n          if (type === DnDTypes.EVENT) {\n            const initialPoint = monitor.getInitialClientOffset();\n            let initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n            initialStart = resourceEvents.headerItems[initialLeftIndex].start;\n            initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\n            if (cellUnit !== CellUnits.Hour) initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          }\n\n          const point = monitor.getClientOffset();\n          let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n          let newStart = resourceEvents.headerItems[leftIndex].start;\n          let newEnd = resourceEvents.headerItems[leftIndex].end;\n          if (cellUnit !== CellUnits.Hour) newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          let slotId = resourceEvents.slotId,\n              slotName = resourceEvents.slotName;\n          let action = 'New';\n          let isEvent = type === DnDTypes.EVENT;\n\n          if (isEvent) {\n            const event = item;\n\n            if (config.relativeMove) {\n              newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(DATETIME_FORMAT);\n            } else {\n              if (viewType !== ViewTypes.Day) {\n                let tmpMoment = localeMoment(newStart);\n                newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(DATETIME_FORMAT);\n              }\n            }\n\n            newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n            if (config.crossResourceMove === false) {\n              slotId = schedulerData._getEventSlotId(item);\n              slotName = undefined;\n              let slot = schedulerData.getSlotById(slotId);\n              if (!!slot) slotName = slot.name;\n            }\n\n            action = 'Move';\n          }\n\n          if (!!movingEvent) {\n            movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\n          }\n        },\n        canDrop: (props, monitor) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents;\n          const item = monitor.getItem();\n          if (schedulerData._isResizing()) return false;\n          const config = schedulerData.config;\n          return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\n        }\n      };\n    };\n\n    this.getDropCollect = (connect, monitor) => {\n      return {\n        connectDropTarget: connect.dropTarget(),\n        isOver: monitor.isOver()\n      };\n    };\n\n    this.getDropTarget = () => {\n      return DropTarget([...this.sourceMap.keys()], this.getDropSpec(), this.getDropCollect)(this.DecoratedComponent);\n    };\n\n    this.getDndSource = (dndType = DnDTypes.EVENT) => {\n      return this.sourceMap.get(dndType);\n    };\n\n    this.sourceMap = new Map();\n    sources.forEach(item => {\n      this.sourceMap.set(item.dndType, item);\n    });\n    this.DecoratedComponent = DecoratedComponent;\n  }\n\n}","map":{"version":3,"sources":["/Users/thomasjd/Desktop/caltask/src/containers/RightCockpit/src/DnDContext.js"],"names":["DropTarget","getPos","DnDTypes","CellUnits","DATETIME_FORMAT","ViewTypes","DnDContext","constructor","sources","DecoratedComponent","getDropSpec","drop","props","monitor","component","schedulerData","resourceEvents","cellUnit","localeMoment","type","getItemType","pos","eventContainer","cellWidth","getContentCellWidth","initialStartTime","initialEndTime","EVENT","initialPoint","getInitialClientOffset","initialLeftIndex","Math","floor","x","headerItems","start","end","Hour","hour","minute","second","format","point","getClientOffset","leftIndex","startTime","endTime","slotId","slotName","initialStart","initialEnd","hover","movingEvent","config","viewType","item","getItem","newStart","newEnd","action","isEvent","event","relativeMove","add","diff","Day","tmpMoment","year","month","date","crossResourceMove","_getEventSlotId","undefined","slot","getSlotById","name","canDrop","_isResizing","movable","groupOnly","getDropCollect","connect","connectDropTarget","dropTarget","isOver","getDropTarget","sourceMap","keys","getDndSource","dndType","get","Map","forEach","set"],"mappings":"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","sourcesContent":["import { DropTarget } from 'react-dnd'\r\nimport {getPos} from './Util'\r\nimport {DnDTypes} from './DnDTypes'\r\nimport {CellUnits, DATETIME_FORMAT} from './index'\r\nimport {ViewTypes} from './ViewTypes'\r\n\r\nexport default class DnDContext {\r\n    constructor(sources, DecoratedComponent) {\r\n        this.sourceMap = new Map();\r\n        sources.forEach((item) => {\r\n            this.sourceMap.set(item.dndType, item);\r\n        })\r\n        this.DecoratedComponent = DecoratedComponent;\r\n    }\r\n\r\n    getDropSpec = () => {\r\n        return {\r\n            drop: (props, monitor, component) =>{\r\n                const {schedulerData, resourceEvents} = props;\r\n                const {cellUnit, localeMoment} = schedulerData;\r\n                const type = monitor.getItemType();\r\n                const pos = getPos(component.eventContainer);\r\n                let cellWidth = schedulerData.getContentCellWidth();\r\n                let initialStartTime = null, initialEndTime = null;\r\n                if(type === DnDTypes.EVENT) {\r\n                    const initialPoint = monitor.getInitialClientOffset();\r\n                    let initialLeftIndex = Math.floor((initialPoint.x - pos.x)/cellWidth);\r\n                    initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\r\n                    initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\r\n                    if(cellUnit !== CellUnits.Hour)\r\n                        initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\r\n                }\r\n                const point = monitor.getClientOffset();                \r\n                let leftIndex = Math.floor((point.x - pos.x)/cellWidth);\r\n                let startTime = resourceEvents.headerItems[leftIndex].start;\r\n                let endTime = resourceEvents.headerItems[leftIndex].end;\r\n                if(cellUnit !== CellUnits.Hour)\r\n                    endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\r\n\r\n                return {\r\n                    slotId: resourceEvents.slotId,\r\n                    slotName: resourceEvents.slotName,\r\n                    start: startTime,\r\n                    end: endTime,\r\n                    initialStart: initialStartTime,\r\n                    initialEnd: initialEndTime\r\n                };\r\n            },\r\n\r\n            hover: (props, monitor, component) => {\r\n                const {schedulerData, resourceEvents, movingEvent} = props;\r\n                const {cellUnit, config, viewType, localeMoment} = schedulerData;\r\n                const item = monitor.getItem();\r\n                const type = monitor.getItemType();\r\n                const pos = getPos(component.eventContainer);\r\n                let cellWidth = schedulerData.getContentCellWidth();\r\n                let initialStart = null, initialEnd = null;\r\n                if(type === DnDTypes.EVENT) {\r\n                    const initialPoint = monitor.getInitialClientOffset();\r\n                    let initialLeftIndex = Math.floor((initialPoint.x - pos.x)/cellWidth);\r\n                    initialStart = resourceEvents.headerItems[initialLeftIndex].start;\r\n                    initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\r\n                    if(cellUnit !== CellUnits.Hour)\r\n                        initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\r\n                }\r\n                const point = monitor.getClientOffset();                \r\n                let leftIndex = Math.floor((point.x - pos.x)/cellWidth);\r\n                let newStart = resourceEvents.headerItems[leftIndex].start;\r\n                let newEnd = resourceEvents.headerItems[leftIndex].end;\r\n                if(cellUnit !== CellUnits.Hour)\r\n                    newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\r\n                let slotId = resourceEvents.slotId, slotName = resourceEvents.slotName;\r\n                let action = 'New';\r\n                let isEvent = type === DnDTypes.EVENT;\r\n                if(isEvent) {\r\n                    const event = item;\r\n                    if(config.relativeMove) {\r\n                        newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(DATETIME_FORMAT);\r\n                    } else {\r\n                        if(viewType !== ViewTypes.Day) {\r\n                            let tmpMoment = localeMoment(newStart);\r\n                            newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(DATETIME_FORMAT);\r\n                        }\r\n                    }\r\n                    newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(DATETIME_FORMAT);\r\n\r\n                    //if crossResourceMove disabled, slot returns old value\r\n                    if(config.crossResourceMove === false) {\r\n                        slotId = schedulerData._getEventSlotId(item);\r\n                        slotName = undefined;\r\n                        let slot = schedulerData.getSlotById(slotId);\r\n                        if(!!slot)\r\n                            slotName = slot.name;\r\n                    }\r\n\r\n                    action = 'Move';\r\n                }\r\n\r\n                if(!!movingEvent) {\r\n                    movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\r\n                }\r\n            },\r\n\r\n            canDrop: (props, monitor) => {\r\n                const {schedulerData, resourceEvents} = props;\r\n                const item = monitor.getItem();\r\n                if(schedulerData._isResizing()) return false;\r\n                const {config} = schedulerData;\r\n                return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\r\n            }\r\n        }\r\n    }\r\n\r\n    getDropCollect = (connect, monitor) => {\r\n        return {\r\n            connectDropTarget: connect.dropTarget(),\r\n            isOver: monitor.isOver()\r\n        };\r\n    }\r\n\r\n    getDropTarget = () => {\r\n        return DropTarget([...this.sourceMap.keys()], this.getDropSpec(), this.getDropCollect)(this.DecoratedComponent);\r\n    }\r\n\r\n    getDndSource = (dndType = DnDTypes.EVENT) => {\r\n        return this.sourceMap.get(dndType);\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}