{"ast":null,"code":"import { DropTarget } from 'react-dnd';\nimport { getPos } from './Util';\nimport { DnDTypes } from './DnDTypes';\nimport { CellUnits, DATETIME_FORMAT } from './index';\nimport ViewTypes from './ViewTypes';\nexport default class DnDContext {\n  constructor(sources, DecoratedComponent) {\n    this.getDropSpec = () => {\n      return {\n        drop: (props, monitor, component) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents;\n          const cellUnit = schedulerData.cellUnit,\n                localeMoment = schedulerData.localeMoment;\n          const type = monitor.getItemType();\n          const pos = getPos(component.eventContainer);\n          let cellWidth = schedulerData.getContentCellWidth();\n          let initialStartTime = null,\n              initialEndTime = null;\n\n          if (type === DnDTypes.EVENT) {\n            const initialPoint = monitor.getInitialClientOffset();\n            let initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n            initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n            initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n            if (cellUnit !== CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          }\n\n          const point = monitor.getClientOffset();\n          let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n          let startTime = resourceEvents.headerItems[leftIndex].start;\n          let endTime = resourceEvents.headerItems[leftIndex].end;\n          if (cellUnit !== CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          return {\n            slotId: resourceEvents.slotId,\n            slotName: resourceEvents.slotName,\n            start: startTime,\n            end: endTime,\n            initialStart: initialStartTime,\n            initialEnd: initialEndTime\n          };\n        },\n        hover: (props, monitor, component) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents,\n                movingEvent = props.movingEvent;\n          const cellUnit = schedulerData.cellUnit,\n                config = schedulerData.config,\n                viewType = schedulerData.viewType,\n                localeMoment = schedulerData.localeMoment;\n          const item = monitor.getItem();\n          const type = monitor.getItemType();\n          const pos = getPos(component.eventContainer);\n          let cellWidth = schedulerData.getContentCellWidth();\n          let initialStart = null,\n              initialEnd = null;\n\n          if (type === DnDTypes.EVENT) {\n            const initialPoint = monitor.getInitialClientOffset();\n            let initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n            initialStart = resourceEvents.headerItems[initialLeftIndex].start;\n            initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\n            if (cellUnit !== CellUnits.Hour) initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          }\n\n          const point = monitor.getClientOffset();\n          let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n          let newStart = resourceEvents.headerItems[leftIndex].start;\n          let newEnd = resourceEvents.headerItems[leftIndex].end;\n          if (cellUnit !== CellUnits.Hour) newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(DATETIME_FORMAT);\n          let slotId = resourceEvents.slotId,\n              slotName = resourceEvents.slotName;\n          let action = 'New';\n          let isEvent = type === DnDTypes.EVENT;\n\n          if (isEvent) {\n            const event = item;\n\n            if (config.relativeMove) {\n              newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(DATETIME_FORMAT);\n            } else {\n              if (viewType !== ViewTypes.Day) {\n                let tmpMoment = localeMoment(newStart);\n                newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(DATETIME_FORMAT);\n              }\n            }\n\n            newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n            if (config.crossResourceMove === false) {\n              slotId = schedulerData._getEventSlotId(item);\n              slotName = undefined;\n              let slot = schedulerData.getSlotById(slotId);\n              if (!!slot) slotName = slot.name;\n            }\n\n            action = 'Move';\n          }\n\n          if (!!movingEvent) {\n            movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\n          }\n        },\n        canDrop: (props, monitor) => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents;\n          const item = monitor.getItem();\n          if (schedulerData._isResizing()) return false;\n          const config = schedulerData.config;\n          return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\n        }\n      };\n    };\n\n    this.getDropCollect = (connect, monitor) => {\n      return {\n        connectDropTarget: connect.dropTarget(),\n        isOver: monitor.isOver()\n      };\n    };\n\n    this.getDropTarget = () => {\n      return DropTarget([...this.sourceMap.keys()], this.getDropSpec(), this.getDropCollect)(this.DecoratedComponent);\n    };\n\n    this.getDndSource = (dndType = DnDTypes.EVENT) => {\n      return this.sourceMap.get(dndType);\n    };\n\n    this.sourceMap = new Map();\n    sources.forEach(item => {\n      this.sourceMap.set(item.dndType, item);\n    });\n    this.DecoratedComponent = DecoratedComponent;\n  }\n\n}","map":{"version":3,"sources":["/Users/thomasjd/Desktop/caltask/src/containers/RightCockpit/src/DnDContext.js"],"names":["DropTarget","getPos","DnDTypes","CellUnits","DATETIME_FORMAT","ViewTypes","DnDContext","constructor","sources","DecoratedComponent","getDropSpec","drop","props","monitor","component","schedulerData","resourceEvents","cellUnit","localeMoment","type","getItemType","pos","eventContainer","cellWidth","getContentCellWidth","initialStartTime","initialEndTime","EVENT","initialPoint","getInitialClientOffset","initialLeftIndex","Math","floor","x","headerItems","start","end","Hour","hour","minute","second","format","point","getClientOffset","leftIndex","startTime","endTime","slotId","slotName","initialStart","initialEnd","hover","movingEvent","config","viewType","item","getItem","newStart","newEnd","action","isEvent","event","relativeMove","add","diff","Day","tmpMoment","year","month","date","crossResourceMove","_getEventSlotId","undefined","slot","getSlotById","name","canDrop","_isResizing","movable","groupOnly","getDropCollect","connect","connectDropTarget","dropTarget","isOver","getDropTarget","sourceMap","keys","getDndSource","dndType","get","Map","forEach","set"],"mappings":"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","sourcesContent":["import { DropTarget } from 'react-dnd';\r\nimport { getPos } from './Util';\r\nimport { DnDTypes } from './DnDTypes';\r\nimport { CellUnits, DATETIME_FORMAT } from './index';\r\nimport ViewTypes from './ViewTypes';\r\n\r\nexport default class DnDContext {\r\n  constructor(sources, DecoratedComponent) {\r\n    this.sourceMap = new Map();\r\n    sources.forEach(item => {\r\n      this.sourceMap.set(item.dndType, item);\r\n    });\r\n    this.DecoratedComponent = DecoratedComponent;\r\n  }\r\n\r\n  getDropSpec = () => {\r\n    return {\r\n      drop: (props, monitor, component) => {\r\n        const { schedulerData, resourceEvents } = props;\r\n        const { cellUnit, localeMoment } = schedulerData;\r\n        const type = monitor.getItemType();\r\n        const pos = getPos(component.eventContainer);\r\n        let cellWidth = schedulerData.getContentCellWidth();\r\n        let initialStartTime = null,\r\n          initialEndTime = null;\r\n        if (type === DnDTypes.EVENT) {\r\n          const initialPoint = monitor.getInitialClientOffset();\r\n          let initialLeftIndex = Math.floor(\r\n            (initialPoint.x - pos.x) / cellWidth\r\n          );\r\n          initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\r\n          initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\r\n          if (cellUnit !== CellUnits.Hour)\r\n            initialEndTime = localeMoment(\r\n              resourceEvents.headerItems[initialLeftIndex].start\r\n            )\r\n              .hour(23)\r\n              .minute(59)\r\n              .second(59)\r\n              .format(DATETIME_FORMAT);\r\n        }\r\n        const point = monitor.getClientOffset();\r\n        let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\r\n        let startTime = resourceEvents.headerItems[leftIndex].start;\r\n        let endTime = resourceEvents.headerItems[leftIndex].end;\r\n        if (cellUnit !== CellUnits.Hour)\r\n          endTime = localeMoment(resourceEvents.headerItems[leftIndex].start)\r\n            .hour(23)\r\n            .minute(59)\r\n            .second(59)\r\n            .format(DATETIME_FORMAT);\r\n\r\n        return {\r\n          slotId: resourceEvents.slotId,\r\n          slotName: resourceEvents.slotName,\r\n          start: startTime,\r\n          end: endTime,\r\n          initialStart: initialStartTime,\r\n          initialEnd: initialEndTime\r\n        };\r\n      },\r\n\r\n      hover: (props, monitor, component) => {\r\n        const { schedulerData, resourceEvents, movingEvent } = props;\r\n        const { cellUnit, config, viewType, localeMoment } = schedulerData;\r\n        const item = monitor.getItem();\r\n        const type = monitor.getItemType();\r\n        const pos = getPos(component.eventContainer);\r\n        let cellWidth = schedulerData.getContentCellWidth();\r\n        let initialStart = null,\r\n          initialEnd = null;\r\n        if (type === DnDTypes.EVENT) {\r\n          const initialPoint = monitor.getInitialClientOffset();\r\n          let initialLeftIndex = Math.floor(\r\n            (initialPoint.x - pos.x) / cellWidth\r\n          );\r\n          initialStart = resourceEvents.headerItems[initialLeftIndex].start;\r\n          initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\r\n          if (cellUnit !== CellUnits.Hour)\r\n            initialEnd = localeMoment(\r\n              resourceEvents.headerItems[initialLeftIndex].start\r\n            )\r\n              .hour(23)\r\n              .minute(59)\r\n              .second(59)\r\n              .format(DATETIME_FORMAT);\r\n        }\r\n        const point = monitor.getClientOffset();\r\n        let leftIndex = Math.floor((point.x - pos.x) / cellWidth);\r\n        let newStart = resourceEvents.headerItems[leftIndex].start;\r\n        let newEnd = resourceEvents.headerItems[leftIndex].end;\r\n        if (cellUnit !== CellUnits.Hour)\r\n          newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start)\r\n            .hour(23)\r\n            .minute(59)\r\n            .second(59)\r\n            .format(DATETIME_FORMAT);\r\n        let slotId = resourceEvents.slotId,\r\n          slotName = resourceEvents.slotName;\r\n        let action = 'New';\r\n        let isEvent = type === DnDTypes.EVENT;\r\n        if (isEvent) {\r\n          const event = item;\r\n          if (config.relativeMove) {\r\n            newStart = localeMoment(event.start)\r\n              .add(\r\n                localeMoment(newStart).diff(localeMoment(initialStart)),\r\n                'ms'\r\n              )\r\n              .format(DATETIME_FORMAT);\r\n          } else {\r\n            if (viewType !== ViewTypes.Day) {\r\n              let tmpMoment = localeMoment(newStart);\r\n              newStart = localeMoment(event.start)\r\n                .year(tmpMoment.year())\r\n                .month(tmpMoment.month())\r\n                .date(tmpMoment.date())\r\n                .format(DATETIME_FORMAT);\r\n            }\r\n          }\r\n          newEnd = localeMoment(newStart)\r\n            .add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms')\r\n            .format(DATETIME_FORMAT);\r\n\r\n          //if crossResourceMove disabled, slot returns old value\r\n          if (config.crossResourceMove === false) {\r\n            slotId = schedulerData._getEventSlotId(item);\r\n            slotName = undefined;\r\n            let slot = schedulerData.getSlotById(slotId);\r\n            if (!!slot) slotName = slot.name;\r\n          }\r\n\r\n          action = 'Move';\r\n        }\r\n\r\n        if (!!movingEvent) {\r\n          movingEvent(\r\n            schedulerData,\r\n            slotId,\r\n            slotName,\r\n            newStart,\r\n            newEnd,\r\n            action,\r\n            type,\r\n            item\r\n          );\r\n        }\r\n      },\r\n\r\n      canDrop: (props, monitor) => {\r\n        const { schedulerData, resourceEvents } = props;\r\n        const item = monitor.getItem();\r\n        if (schedulerData._isResizing()) return false;\r\n        const { config } = schedulerData;\r\n        return (\r\n          config.movable &&\r\n          !resourceEvents.groupOnly &&\r\n          (item.movable == undefined || item.movable !== false)\r\n        );\r\n      }\r\n    };\r\n  };\r\n\r\n  getDropCollect = (connect, monitor) => {\r\n    return {\r\n      connectDropTarget: connect.dropTarget(),\r\n      isOver: monitor.isOver()\r\n    };\r\n  };\r\n\r\n  getDropTarget = () => {\r\n    return DropTarget(\r\n      [...this.sourceMap.keys()],\r\n      this.getDropSpec(),\r\n      this.getDropCollect\r\n    )(this.DecoratedComponent);\r\n  };\r\n\r\n  getDndSource = (dndType = DnDTypes.EVENT) => {\r\n    return this.sourceMap.get(dndType);\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}