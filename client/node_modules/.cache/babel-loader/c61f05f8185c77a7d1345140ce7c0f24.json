{"ast":null,"code":"import { DragSource } from 'react-dnd';\nimport { ViewTypes, DATETIME_FORMAT } from './index';\nimport { DnDTypes } from './DnDTypes';\nexport default class DnDSource {\n  constructor(resolveDragObjFunc, DecoratedComponent, dndType = DnDTypes.EVENT) {\n    this.getDragSpec = () => {\n      return {\n        beginDrag: (props, monitor, component) => {\n          return this.resolveDragObjFunc(props);\n        },\n        endDrag: (props, monitor, component) => {\n          if (!monitor.didDrop()) return;\n          const moveEvent = props.moveEvent,\n                newEvent = props.newEvent,\n                schedulerData = props.schedulerData;\n          const events = schedulerData.events,\n                config = schedulerData.config,\n                viewType = schedulerData.viewType,\n                localeMoment = schedulerData.localeMoment;\n          const item = monitor.getItem();\n          const type = monitor.getItemType();\n          const dropResult = monitor.getDropResult();\n          let slotId = dropResult.slotId,\n              slotName = dropResult.slotName;\n          let newStart = dropResult.start,\n              newEnd = dropResult.end;\n          let initialStart = dropResult.initialStart,\n              initialEnd = dropResult.initialEnd;\n          let action = 'New';\n          let isEvent = type === DnDTypes.EVENT;\n\n          if (isEvent) {\n            const event = item;\n\n            if (config.relativeMove) {\n              newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(DATETIME_FORMAT);\n            } else {\n              if (viewType !== ViewTypes.Day) {\n                let tmpMoment = localeMoment(newStart);\n                newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(DATETIME_FORMAT);\n              }\n            }\n\n            newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n            if (config.crossResourceMove === false) {\n              slotId = schedulerData._getEventSlotId(item);\n              slotName = undefined;\n              let slot = schedulerData.getSlotById(slotId);\n              if (!!slot) slotName = slot.name;\n            }\n\n            action = 'Move';\n          }\n\n          let hasConflict = false;\n\n          if (config.checkConflict) {\n            let start = localeMoment(newStart),\n                end = localeMoment(newEnd);\n            events.forEach(e => {\n              if (schedulerData._getEventSlotId(e) === slotId && (!isEvent || e.id !== item.id)) {\n                let eStart = localeMoment(e.start),\n                    eEnd = localeMoment(e.end);\n                if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n              }\n            });\n          }\n\n          if (hasConflict) {\n            const conflictOccurred = props.conflictOccurred;\n\n            if (conflictOccurred != undefined) {\n              conflictOccurred(schedulerData, action, item, type, slotId, slotName, newStart, newEnd);\n            } else {\n              console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n            }\n          } else {\n            if (isEvent) {\n              if (moveEvent !== undefined) {\n                moveEvent(schedulerData, item, slotId, slotName, newStart, newEnd);\n              }\n            } else {\n              if (newEvent !== undefined) newEvent(schedulerData, slotId, slotName, newStart, newEnd, type, item);\n            }\n          }\n        },\n        canDrag: props => {\n          const schedulerData = props.schedulerData,\n                resourceEvents = props.resourceEvents;\n          const item = this.resolveDragObjFunc(props);\n          if (schedulerData._isResizing()) return false;\n          const config = schedulerData.config;\n          return config.movable && (resourceEvents == undefined || !resourceEvents.groupOnly) && (item.movable == undefined || item.movable !== false);\n        }\n      };\n    };\n\n    this.getDragCollect = (connect, monitor) => {\n      return {\n        connectDragSource: connect.dragSource(),\n        isDragging: monitor.isDragging(),\n        connectDragPreview: connect.dragPreview()\n      };\n    };\n\n    this.getDragSource = () => {\n      return this.dragSource;\n    };\n\n    this.resolveDragObjFunc = resolveDragObjFunc;\n    this.DecoratedComponent = DecoratedComponent;\n    this.dndType = dndType;\n    this.dragSource = DragSource(this.dndType, this.getDragSpec(), this.getDragCollect)(this.DecoratedComponent);\n  }\n\n}","map":{"version":3,"sources":["/Users/thomasjd/Desktop/caltask/src/containers/RightCockpit/src/DnDSource.js"],"names":["DragSource","ViewTypes","DATETIME_FORMAT","DnDTypes","DnDSource","constructor","resolveDragObjFunc","DecoratedComponent","dndType","EVENT","getDragSpec","beginDrag","props","monitor","component","endDrag","didDrop","moveEvent","newEvent","schedulerData","events","config","viewType","localeMoment","item","getItem","type","getItemType","dropResult","getDropResult","slotId","slotName","newStart","start","newEnd","end","initialStart","initialEnd","action","isEvent","event","relativeMove","add","diff","format","Day","tmpMoment","year","month","date","crossResourceMove","_getEventSlotId","undefined","slot","getSlotById","name","hasConflict","checkConflict","forEach","e","id","eStart","eEnd","conflictOccurred","console","log","canDrag","resourceEvents","_isResizing","movable","groupOnly","getDragCollect","connect","connectDragSource","dragSource","isDragging","connectDragPreview","dragPreview","getDragSource"],"mappings":"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","sourcesContent":["import { DragSource } from 'react-dnd'\r\nimport {ViewTypes, DATETIME_FORMAT} from './index'\r\nimport {DnDTypes} from './DnDTypes'\r\n\r\nexport default class DnDSource {\r\n    constructor(resolveDragObjFunc, DecoratedComponent, dndType = DnDTypes.EVENT) {\r\n        this.resolveDragObjFunc = resolveDragObjFunc;\r\n        this.DecoratedComponent = DecoratedComponent;\r\n        this.dndType = dndType;\r\n        this.dragSource = DragSource(this.dndType, this.getDragSpec(), this.getDragCollect)(this.DecoratedComponent);\r\n    }\r\n\r\n    getDragSpec = () => {\r\n        return {\r\n            beginDrag: (props, monitor, component) => {\r\n                return this.resolveDragObjFunc(props);\r\n            },\r\n            endDrag: (props, monitor, component) => {\r\n                if(!monitor.didDrop()) return;\r\n\r\n                const {moveEvent, newEvent, schedulerData } = props;\r\n                const {events, config, viewType, localeMoment} = schedulerData;\r\n                const item = monitor.getItem();\r\n                const type = monitor.getItemType();\r\n                const dropResult = monitor.getDropResult();\r\n                let slotId = dropResult.slotId, slotName = dropResult.slotName;\r\n                let newStart = dropResult.start, newEnd = dropResult.end;\r\n                let initialStart = dropResult.initialStart, initialEnd = dropResult.initialEnd;\r\n                let action = 'New';\r\n\r\n                let isEvent = type === DnDTypes.EVENT;\r\n                if(isEvent) {\r\n                    const event = item;\r\n                    if(config.relativeMove) {\r\n                        newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(DATETIME_FORMAT);\r\n                    } else {\r\n                        if(viewType !== ViewTypes.Day) {\r\n                            let tmpMoment = localeMoment(newStart);\r\n                            newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(DATETIME_FORMAT);\r\n                        }\r\n                    }\r\n                    newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(DATETIME_FORMAT);\r\n\r\n                    //if crossResourceMove disabled, slot returns old value\r\n                    if(config.crossResourceMove === false) {\r\n                        slotId = schedulerData._getEventSlotId(item);\r\n                        slotName = undefined;\r\n                        let slot = schedulerData.getSlotById(slotId);\r\n                        if(!!slot)\r\n                            slotName = slot.name;\r\n                    }\r\n\r\n                    action = 'Move';\r\n                }\r\n\r\n                let hasConflict = false;\r\n                if(config.checkConflict) {\r\n                    let start = localeMoment(newStart),\r\n                        end = localeMoment(newEnd);\r\n\r\n                    events.forEach((e) =>{\r\n                        if(schedulerData._getEventSlotId(e) === slotId && (!isEvent || e.id !== item.id)) {\r\n                            let eStart = localeMoment(e.start),\r\n                                eEnd = localeMoment(e.end);\r\n                            if((start >= eStart && start < eEnd) || (end > eStart && end <= eEnd) || (eStart >= start && eStart < end) || (eEnd > start && eEnd <= end))\r\n                                hasConflict = true;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if(hasConflict) {\r\n                    const {conflictOccurred} = props;\r\n                    if(conflictOccurred != undefined){\r\n                        conflictOccurred(schedulerData, action, item, type, slotId, slotName, newStart, newEnd);\r\n                    }\r\n                    else {\r\n                        console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\r\n                    }\r\n                }\r\n                else {\r\n                    if(isEvent) {\r\n                        if (moveEvent !== undefined) {\r\n                            moveEvent(schedulerData, item, slotId, slotName, newStart, newEnd);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if(newEvent !== undefined)\r\n                            newEvent(schedulerData, slotId, slotName, newStart, newEnd, type, item);\r\n                    }\r\n                }\r\n            },\r\n\r\n            canDrag: (props) => {\r\n                const {schedulerData, resourceEvents} = props;\r\n                const item = this.resolveDragObjFunc(props);\r\n                if(schedulerData._isResizing()) return false;\r\n                const {config} = schedulerData;\r\n                return config.movable && (resourceEvents == undefined || !resourceEvents.groupOnly) && (item.movable == undefined || item.movable !== false);\r\n            }\r\n        }\r\n    }\r\n\r\n    getDragCollect = (connect, monitor) => {\r\n        return {\r\n            connectDragSource: connect.dragSource(),\r\n            isDragging: monitor.isDragging(),\r\n            connectDragPreview: connect.dragPreview()\r\n        };\r\n    }\r\n\r\n    getDragSource = () => {\r\n        return this.dragSource;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}