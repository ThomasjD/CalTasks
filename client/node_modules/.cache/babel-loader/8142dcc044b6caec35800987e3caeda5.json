{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $parseInt = GetIntrinsic('%parseInt%');\n\nvar inspect = require('object-inspect');\n\nvar regexTester = require('../helpers/regexTester');\n\nvar callBound = require('../helpers/callBound');\n\nvar every = require('../helpers/every');\n\nvar isDigit = regexTester(/^[0-9]$/);\nvar strSlice = callBound('String.prototype.slice');\n\nvar IsArray = require('./IsArray');\n\nvar IsInteger = require('./IsInteger');\n\nvar Type = require('./Type'); // https://www.ecma-international.org/ecma-262/6.0/#sec-getsubstitution\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\n\n\nmodule.exports = function GetSubstitution(matched, str, position, captures, replacement) {\n  if (Type(matched) !== 'String') {\n    throw new $TypeError('Assertion failed: `matched` must be a String');\n  }\n\n  var matchLength = matched.length;\n\n  if (Type(str) !== 'String') {\n    throw new $TypeError('Assertion failed: `str` must be a String');\n  }\n\n  var stringLength = str.length;\n\n  if (!IsInteger(position) || position < 0 || position > stringLength) {\n    throw new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));\n  }\n\n  var ES = this;\n\n  var isStringOrHole = function (capture, index, arr) {\n    return ES.Type(capture) === 'String' || !(index in arr);\n  };\n\n  if (!IsArray(captures) || !every(captures, isStringOrHole)) {\n    throw new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));\n  }\n\n  if (Type(replacement) !== 'String') {\n    throw new $TypeError('Assertion failed: `replacement` must be a String');\n  }\n\n  var tailPos = position + matchLength;\n  var m = captures.length;\n  var result = '';\n\n  for (var i = 0; i < replacement.length; i += 1) {\n    // if this is a $, and it's not the end of the replacement\n    var current = replacement[i];\n    var isLast = i + 1 >= replacement.length;\n    var nextIsLast = i + 2 >= replacement.length;\n\n    if (current === '$' && !isLast) {\n      var next = replacement[i + 1];\n\n      if (next === '$') {\n        result += '$';\n        i += 1;\n      } else if (next === '&') {\n        result += matched;\n        i += 1;\n      } else if (next === '`') {\n        result += position === 0 ? '' : strSlice(str, 0, position - 1);\n        i += 1;\n      } else if (next === \"'\") {\n        result += tailPos >= stringLength ? '' : strSlice(str, tailPos);\n        i += 1;\n      } else {\n        var nextNext = nextIsLast ? null : replacement[i + 2];\n\n        if (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {\n          // $1 through $9, and not followed by a digit\n          var n = $parseInt(next, 10); // if (n > m, impl-defined)\n\n          result += n <= m && Type(captures[n - 1]) === 'Undefined' ? '' : captures[n - 1];\n          i += 1;\n        } else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {\n          // $00 through $99\n          var nn = next + nextNext;\n          var nnI = $parseInt(nn, 10) - 1; // if nn === '00' or nn > m, impl-defined\n\n          result += nn <= m && Type(captures[nnI]) === 'Undefined' ? '' : captures[nnI];\n          i += 2;\n        } else {\n          result += '$';\n        }\n      }\n    } else {\n      // the final $, or else not a $\n      result += replacement[i];\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/Users/thomasjd/Desktop/caltask/client/node_modules/es-abstract/2015/GetSubstitution.js"],"names":["GetIntrinsic","require","$TypeError","$parseInt","inspect","regexTester","callBound","every","isDigit","strSlice","IsArray","IsInteger","Type","module","exports","GetSubstitution","matched","str","position","captures","replacement","matchLength","length","stringLength","ES","isStringOrHole","capture","index","arr","tailPos","m","result","i","current","isLast","nextIsLast","next","nextNext","n","nn","nnI"],"mappings":"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","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $parseInt = GetIntrinsic('%parseInt%');\n\nvar inspect = require('object-inspect');\n\nvar regexTester = require('../helpers/regexTester');\nvar callBound = require('../helpers/callBound');\nvar every = require('../helpers/every');\n\nvar isDigit = regexTester(/^[0-9]$/);\n\nvar strSlice = callBound('String.prototype.slice');\n\nvar IsArray = require('./IsArray');\nvar IsInteger = require('./IsInteger');\nvar Type = require('./Type');\n\n// https://www.ecma-international.org/ecma-262/6.0/#sec-getsubstitution\n\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\nmodule.exports = function GetSubstitution(matched, str, position, captures, replacement) {\n\tif (Type(matched) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `matched` must be a String');\n\t}\n\tvar matchLength = matched.length;\n\n\tif (Type(str) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `str` must be a String');\n\t}\n\tvar stringLength = str.length;\n\n\tif (!IsInteger(position) || position < 0 || position > stringLength) {\n\t\tthrow new $TypeError('Assertion failed: `position` must be a nonnegative integer, and less than or equal to the length of `string`, got ' + inspect(position));\n\t}\n\n\tvar ES = this;\n\tvar isStringOrHole = function (capture, index, arr) { return ES.Type(capture) === 'String' || !(index in arr); };\n\tif (!IsArray(captures) || !every(captures, isStringOrHole)) {\n\t\tthrow new $TypeError('Assertion failed: `captures` must be a List of Strings, got ' + inspect(captures));\n\t}\n\n\tif (Type(replacement) !== 'String') {\n\t\tthrow new $TypeError('Assertion failed: `replacement` must be a String');\n\t}\n\n\tvar tailPos = position + matchLength;\n\tvar m = captures.length;\n\n\tvar result = '';\n\tfor (var i = 0; i < replacement.length; i += 1) {\n\t\t// if this is a $, and it's not the end of the replacement\n\t\tvar current = replacement[i];\n\t\tvar isLast = (i + 1) >= replacement.length;\n\t\tvar nextIsLast = (i + 2) >= replacement.length;\n\t\tif (current === '$' && !isLast) {\n\t\t\tvar next = replacement[i + 1];\n\t\t\tif (next === '$') {\n\t\t\t\tresult += '$';\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '&') {\n\t\t\t\tresult += matched;\n\t\t\t\ti += 1;\n\t\t\t} else if (next === '`') {\n\t\t\t\tresult += position === 0 ? '' : strSlice(str, 0, position - 1);\n\t\t\t\ti += 1;\n\t\t\t} else if (next === \"'\") {\n\t\t\t\tresult += tailPos >= stringLength ? '' : strSlice(str, tailPos);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar nextNext = nextIsLast ? null : replacement[i + 2];\n\t\t\t\tif (isDigit(next) && next !== '0' && (nextIsLast || !isDigit(nextNext))) {\n\t\t\t\t\t// $1 through $9, and not followed by a digit\n\t\t\t\t\tvar n = $parseInt(next, 10);\n\t\t\t\t\t// if (n > m, impl-defined)\n\t\t\t\t\tresult += (n <= m && Type(captures[n - 1]) === 'Undefined') ? '' : captures[n - 1];\n\t\t\t\t\ti += 1;\n\t\t\t\t} else if (isDigit(next) && (nextIsLast || isDigit(nextNext))) {\n\t\t\t\t\t// $00 through $99\n\t\t\t\t\tvar nn = next + nextNext;\n\t\t\t\t\tvar nnI = $parseInt(nn, 10) - 1;\n\t\t\t\t\t// if nn === '00' or nn > m, impl-defined\n\t\t\t\t\tresult += (nn <= m && Type(captures[nnI]) === 'Undefined') ? '' : captures[nnI];\n\t\t\t\t\ti += 2;\n\t\t\t\t} else {\n\t\t\t\t\tresult += '$';\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// the final $, or else not a $\n\t\t\tresult += replacement[i];\n\t\t}\n\t}\n\treturn result;\n};\n"]},"metadata":{},"sourceType":"script"}